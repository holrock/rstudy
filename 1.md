# 対象

* プログラミングをしたことがない人
* Rを触るのが初めての人
* コピペでRを使ってる人

# 全体の目標

* Rの基本を理解して、本やWEBで調べたものの意味がわかるようになる
* Rはなんとなく書いても動くけど、なんとなく書いたら動かなくなったときに、どこが間違ってるかわかるようになる
* 具体的にはデータフレームの取り扱いができるようになるぐらいを目指します
* とりあえず3,4回ぐらいで
    * 数値とベクトル
    * ファクター、マトリックス
    * リストとデータフレーム
    * プロット

# プログラミングを学ぶときの考え方

* エラーは怖くない
    * エラーは出るものです。誰も悪くありません
    * そう簡単に壊れません
    * 何度でもやり直せるし、間違えたことを教えてくるので助かることが多いです
    * エラーメッセージはよく読みましょう
* プログラミングはレシピを身につける作業
    * やりたい事とレシピを結びつけることができるとスムーズにプログラミングできます
    * 何度も書くことで慣れていきます
    * 1万行書いてからが本番です
* 覚えなくても大丈夫
    * 毎回調べるのが普通です
    * 調べ方のほうが重要

# 今回の予定

やれるところまで

* RとRStudioのインストール(終わってるはず)
* Rを動かしてみる
    * ソースコードの写経(R触ったことある人ばっかりだったらスキップ)
* 数値と変数
* ベクトル

# 準備

RとRを使いやすくする統合開発環境のRStudioをインストールします。
RStudioは無くても動きますが、インストールをおすすめします。

## Rのインストール

* Windowsの人
    * https://cran.ism.ac.jp/bin/windows/base/
* Macの人
    * https://cran.ism.ac.jp/bin/macosx/


## RStudioのインストール

https://www.rstudio.com/products/rstudio/download/#download

# Rを動かしてみる

* Rstdioを起動します
* consoleに以下のコードを入力します。
    * `>`と出ているのはプロンプトと言い、ココに入力できますという印です

```r
plot(iris)
```

* Plots画面にグラフが出れば成功です。
![plots](https://raw.githubusercontent.com/holrock/rstudy/master/images/1-1.png)

## 終了する

* consoleに`q()`と入力するか、メニューから`Quit RStdio`を選択してください
* 終了時にworkspaceを保存するかを聞かれることがありますが、基本的には`Don't Save`で大丈夫です
    * 現在の作業内容を保存するかどうかを聞かれているのでそこから再開したいとき以外は不要です

![quit](https://raw.githubusercontent.com/holrock/rstudy/master/images/1-2.png)

## helpの引き方

```r
> help(iris)
> help("+")
> ?iris
```

## 入門セッション

Rの雰囲気をつかむために写経をしてみます。

やってることの中身はあまり木にせずに次のソースコードを一行ずつ打ち込んでみてください。
`#`の行はコメントです。無視してください。

もし`>`の代わりに`+`が表示されたときは、前の行が完結していません。`)`が抜けてないかよく見てみてください。

入力を間違えたときは`↑`キーで前の入力に戻れるので使ってみてください。

```r
# 単純プロット編

# x, y 座標を表す 2 組の正規乱数を生成する
x <- rnorm(50)
y <- rnorm(50)
# その点を平面にプロットする
plot(x, y)

# R の作業スペースにどういう R オブジェクトがあるか
ls()
# 不要なオブジェクトを取り去る (掃除)
rm(x, y)

# 複雑なプロット編

# x = (1,2,...,20) とする
x <- 1:20
# 標準偏差の「重み」ベクトル
w <- 1 + sqrt(x) / 2
# 2 つの列ベクトル x と y の「データフレーム」を作り
dummy <- data.frame(x=x, y= x + rnorm(x) * w)
# それを見る
dummy

# y の x への単純線形回帰当てはめを行い
fm <- lm(y ~ x, data=dummy)
# 解析結果を眺める
summary(fm)
# ノンパラメトリックな局所回帰関数を作る
lrf <- lowess(dummy$x, dummy$y)
# 標準的な点プロット
plot(dummy$x, dummy$y)
# 局所回帰に加える
lines(dummy$x, lrf$y)
# 真の回帰直線:(切片 0，傾き 1)
abline(0, 1, lty=3)
# 重み無しの回帰直線
abline(coef(fm))
# 重み付きの回帰直線
abline(coef(fm1), col = "red")
```

![plot](https://raw.githubusercontent.com/holrock/rstudy/master/images/1-3.png)

Rを使うと統計処理とグラフが簡潔に扱えます。

# 数値と変数

## 基本的な演算

```r
> 1 + 1
[1] 2
> 1 + 2 + 3
[1] 6
> 10 / 5
[1] 2
> 10 / 3
[1] 3.333333
```

`+`, `-`, `*`, `/`のような計算記号を**演算子** (operator) と呼びます。演算子には優先順位があり同じ式の中に複数でてきたときは

1. 乗算・除算
2. 加算・減算

の順に実行されます。括弧内の式は全てに優先されて先に計算されます。

### 練習問題

* `2 * 3 + 4`の結果はなにになるでしょうか
* `2 * (3 + 4)`の結果はなにになるでしょうか
* `(2 * 3) + 4`の結果はなにになるでしょうか

式の結果を予想してから、consoleに打ち込んでみてください。

プログラミングでは、このように式を実行して結果を得ることを、式を評価する (evaluate  expressions) と言うことがあります。
評価した結果を値と呼びます。

### 基本的な演算子

演算|記号
----|----
加算|+
減算|	-
乗算|*
除算|/
余り|%%
べき算|^
より大きい|>
より小さい|<
以上|>=
以下|<=
等しい|==
等しくない|!=

## 整数型と実数型、論理型

Rの値には複数のタイプがあります。タイプのことを型と呼びます。

今回使用するのは以下の型です

* 整数型(1,2,3,4,5,...)
    * `integer`
* 実数型(0.1,0.2,0.3,...)
    * `double`
* 論理型(TRUE, FALSE)
    * `logical`

実数型は浮動小数点数型ということもあります。
`double`という名前は、コンピューター上の実数が、倍精度浮動小数点数と呼ばれていることに由来します。意味は気にしなくて良いです。

論理型は`>`演算子の結果などで、真偽値を扱うときに使用します。

```r
>  1 > 2
[1] FALSE
> 1 < 2
[1] TRUE
```

## 変数と代入

変数とは、式を評価した結果を保持して、再度利用するために名前をつけたものです。

Rでは`<-`が値に名前をつけるための代入演算子になります。

```r
> x <- 1
> x
[1] 1
```

この式では、`1`という式を評価すると1という整数になり、その結果の1に対して`x`という名前をつけています。
一度名前をつけると以後は`x`という名前で1という整数を参照できます。

### 練習問題

* `2 * 3 + 4`の結果に`a`という変数に代入してみましょう
* `a`の値から20を引いた値を`b`という変数に代入してみましょう
* `a %% 3`の結果はなにになるでしょうか
* 2の32乗を計算してみましょう
* `10 == 1`の結果の型はなんでしょうか

### 補足

`remove(x)` もしくは `rm(x)` で代入した変数を削除することができますが、あまり使うことはありません。

# ベクトル

## Rのベクトル

Rにおけるベクトルとは、同じ型(整数なら整数を)１個以上個並べたものをベクトルと呼びます。

```r
> c(1, 2, 3, 4, 5)
[1] 1 2 3 4 5
> 1:50
 [1]  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28
[29] 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50
> 1
[1] 1
```

`c()`で任意のベクトルを作ることができます(cはcombineの略)。

また`1:10`で、1から10までの連続したベクトルを作成できます。
`始点:終点`まで1刻みのベクトルという記法です。

```r
> 5:-7
 [1]  5  4  3  2  1  0 -1 -2 -3 -4 -5 -6 -7
```
ベクトルかどうかを判定するには`is.vector`が使用できます。

```r
> is.vector(1:10)
[1] TRUE
```

### 落とし穴

Rにおいては`1`は要素1個のベクトルです。
Rにはスカラーは無く、要素1個のベクトルとして扱われます。

```r
> is.vector(1)
[1] TRUE
```


## ベクトルと型

`typeof`を使うと値の型を見ることができます。

```r
> typeof(1:10)
[1] "integer"

> typeof(c(1.0))
[1] "double"

> typeof(c(1))
[1] "double"

> typeof(c(1L))
[1] "integer"

> typeof(c(TRUE))
[1] "logical"
```

Rは実数を基本的な型とするので、特に指定がなければ数値は`double`として扱われます。整数として指定したい場合は`1L`のように`L`を後ろにつけます。

### 落とし穴

複数の型を混ぜたベクトルを作ると、より範囲が広い型に変換されます。

```r
> x <- c(FALSE, 1L, 2.0)
> x
[1] 0 1 2
> typeof(x)
[1] "double"

> x <- c(FALSE, 1L)
> x
[1] 0 1
> typeof(x)
[1] "integer"
```

* 論理型のTRUEは1, FALSEは0として扱われます。
* 範囲は double > integer > logicalの順です。
* また数値が期待される場所へ論理型が与えられた場合も同様に数値に変換されます

### 練習問題

次の結果がどうなるか予想してみましょう。
実際にconsoleに打ち込んで結果と比較してみてください。

```r

-5:5

1:0

0:0

1.1:10

is.vector(0)

is.vector(FALSE)

typeof(1)

typeof(1L)

typeof(FALSE)
```


## ベクトル演算

Rはベクトル型言語です。
ベクトル型言語というのはベクトルの演算が簡潔に書けるようになっているプログラミング言語のことです。

```r
> x <- 1:10
> x + 1
 [1]  2  3  4  5  6  7  8  9 10 11
> x * 3
 [1]  3  6  9 12 15 18 21 24 27 30
```

ベクトル同士の演算も簡単に書けます。

```r
> x + x
 [1]  2  4  6  8 10 12 14 16 18 20
> y <- 20:11
> x + y
 [1] 21 21 21 21 21 21 21 21 21 21
> x / y
 [1] 0.0500000 0.1052632 0.1666667 0.2352941 0.3125000 0.4000000 0.5000000 0.6153846
 [9] 0.7500000 0.9090909
```

### 長さが違うベクトル同士の計算

長さが違うベクトル同士の計算では、短い方のベクトルが繰り返し使われます。
ベクトルの長さは`length(x)`で調べられます。

```r
> x <- 1:10
> x
 [1]  1  2  3  4  5  6  7  8  9 10
> length(x)
[1] 10

> y <- 1:2
> y
[1] 1 2
> length(y)
[1] 2

> x * y
 [1]  1  4  3  8  5 12  7 16  9 20
```

このケースでは`y`の長さが2なので、`x`の値にたいして1と2が交互に乗算されています。

x|y|結果
-|-|--
1|1|1
2|2|4
3|1|3
4|2|8
5|1|5
6|2|12
7|1|7
8|2|16
9|1|9
10|2|20

#### 落とし穴

長さが倍数にならないときは警告が出ます。

```r
> y <- 1:3
> length(y)
[1] 3
> x * y
 [1]  1  4  9  4 10 18  7 16 27 10
 警告メッセージ: 
 x * y で: 
   長いオブジェクトの長さが短いオブジェクトの長さの倍数になっていません 
```

### その他の演算

Rの処理はベクトルに対して動くように作られているものが多いです。
(動かないものもあります)


```r
> x <- 1:10

# 合計
> sum(x)
[1] 55

# 算術平均
> mean(x)
[1] 5.5

# 各要素に対して5より小さいか
> x < 5
 [1]  TRUE  TRUE  TRUE  TRUE FALSE FALSE FALSE FALSE FALSE FALSE

# 各要素に対し5以上か
> x >= 5
 [1] FALSE FALSE FALSE FALSE  TRUE  TRUE  TRUE  TRUE  TRUE  TRUE

# 5より小さいものの個数
> sum(x < 5)
[1] 4
```

### 練習問題

* 同じ長さの適当なベクトル`x`, `y`を作って四則演算をやってみましょう
* 違う長さの適当なベクトル`x`, `y`を作って四則演算をやってみましょう
* `x`の分散を計算してみましょう
    * `var`を使います
* `x`の標準偏差を計算してみましょう
    * `sd`を使います
* `abs(-1:-10)`は何をやっているでしょうか
* `cor(1:10, 2:11)`は何をやっているでしょうか
* `sum(x < 5)`が4になる理由を考えてみましょう
* 次の処理結果がどうなるか予想してみてください
```r
> x<-c(0.68, 0.25, 0.67, 0.46, 0.39, 0.11, 0.19, 0.68, 0.65, 0.91)
> min(x)
> max(x)
```

## ベクトルのデータ抽出

ベクトルから特定の要素を抽出したいときには、主に以下の方法があります。

1. 正の数で要素番号を指定する
    2. Rの添字(index)は1から始まります
2. 負数で特定の要素以外を指定する
3. 論理値で指定する

```r
# 1. 正の数で要素を指定する
> x <- c(0.1, 0.2, 0.3, 0.4, 0.5)
> x
[1] 0.1 0.2 0.3 0.4 0.5

> x[1]
[1] 0.1

> x[2:4]
[1] 0.2 0.3 0.4

# 指定した順番で抽出する
> x[c(3, 1)]
[1] 0.3 0.1

# 重複指定すると重複した分だけ抽出できる
> x[c(1,1)]
[1] 0.1 0.1

# 2. 負数で特定の要素以外を抽出できる
> x[-3]
[1] 0.1 0.2 0.4 0.5
> x[-c(4, 1)]
[1] 0.2 0.3 0.5

# 正負を混ぜるとエラー
> x[c(4, -1)]
 x[c(4, -1)] でエラー:  負の添字と混在できるのは 0 という添字だけです 

# 3. 論理値で指定するとTRUEの箇所を抽出できる
> x[c(TRUE, TRUE, TRUE, FALSE, FALSE)]
[1] 0.1 0.2 0.3

# xが0.3より大きいものだけアクセスしたい
> x[x > 0.3]
[1] 0.4 0.5

> x > 0.3
[1] FALSE FALSE FALSE  TRUE  TRUE
```
### 練習問題

* `x <- 1:100` とおいて、
* `x < 20`のものを取り出してみましょう
* `x > 80`のものを取り出してみましょう
* 上の２つの条件をORで組み合わせてみましょう
    * 20より小さい、または80より大きいという条件になります
    * 条件をORで組み合わせるためには`|` 演算子を使います
    *  `x < 20 | x > 80`
    *  ついでに`|`演算子を調べてみましょう
* xから1以外のものを取り出してみましょう
* xから100以外のものを取り出してみましょう
* 負数を使わずに、xから50以外のものを取り出してみましょう
* xから偶数のものを取り出してみましょう
    * ヒント: 余りを使います
* xから奇数のものを取り出してみましょう


# 参考文献

* An Introduction to R
* みんなのRデータ分析と統計解析の新しい教科書
* R言語徹底解説
