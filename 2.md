# 今回の予定

できるところまで

* 前回の復習と補足
* ファクター
* マトリックス
* 欠損値、非数値

# 前回の復習と補足

## ふりかえり

* 前回で気になったった所やわからなかったところなどを一人ずつお願いします
    * 何もなかったら、どんな解析をRを使ってやってみたいかお願いします

## Rの勉強方法

Rの情報はインターネットに色々有りますが、断片的なものが多く、まとまった内容を勉強するには向いてないことが多いです。

この勉強会は基礎編ということであまり発展的な内容は扱いませんが、今後もRを使うのであれば、本やオンラインコースがいいと思います。

### 本

* [みんなのR　データ分析と統計解析の新しい教科書](https://www.amazon.co.jp/dp/B012Z86Q6Q/)
    * この勉強会の種本
    * もうすぐ、みんなのR 第2版が出るみたいです
* [Rクックブック](https://www.amazon.co.jp/dp/4873115337)
* [Rではじめるデータサイエンス](https://www.amazon.co.jp/dp/487311814X/)
* [RStudioではじめるRプログラミング入門](https://www.amazon.co.jp/dp/4873117151)

みんなのRとRクックブックは手元になるのでお見せできます。

プログラミング初心者の方は本見てもわからないということが多いと思います。
そういう方には写経をおすすめします。

* 写経のやり方
    * 実行できるサンプルコードが多い本を選ぶ
    * とりあえずざっと読みながらサンプルコードをすべて写経する
        * わからないところはわからないまま進む
    * 一度終わったら、もう一度最初から写経する
        * 今回は本文も読みながらやってみる
    * 2回めが終わったら、もう一度1行ずつ何をやっているか考えながら写経する

### オンラインコース

自分のペースでできるので独学し易いと思います。
無料のものもおおいので、自宅などでできる人はぜひ

* [edX](https://www.edx.org/)
* [coursera](https://www.coursera.org/)
* [DataCamp](https://www.datacamp.com/)
* [udemy](https://www.udemy.com/jp/)
    * 有料だけど日本語

本職の教育者の人がやっているので、この勉強会よりずっとわかりやすいです。
この勉強会のメリットは周りに聞けるというところなので、わからないことや疑問点など、なんでもいいのですぐに聞きましょう。

## 演算子

### 基本的な演算子

演算|記号
----|----
加算|+
減算|	-
乗算|*
除算|/
余り|%%
べき算|^
より大きい|>
より小さい|<
以上|>=
以下|<=
等しい|==
等しくない|!=
代入演算子|<-

前回省略した演算子

演算|記号|例
----|----|-
整数除算|%/%|`10 %/% 3 → 3`
代入演算子|=|`a = 1`
代入演算子|->|`1 -> a`

代入演算子が色々ありますが、`<-`以外は基本的に使いません

### 論理演算子

記号一個の演算子はベクトル演算用、記号2個の演算子は条件式用

* NOT 否定 `!`

A|`!A`
-|-
TRUE|FALSE
FALSE|TRUE|

* AND 論理積 `&`  `&&`

A|B|`A & B`
-|-|-
TRUE|TRUE|TRUE
TRUE|FALSE|FALSE
FALSE|TRUE|FALSE
FALSE|FALSE|FALSE

* OR 論理和 `|` `||`

A|B|`A \| B`
-|-|-
TRUE|TRUE|TRUE
TRUE|FALSE|TRUE
FALSE|TRUE|TRUE
FALSE|FALSE|FALSE

* xor 排他的論理和

A|B|`xor(A, B)`
-|-|-
TRUE|TRUE|FALSE
TRUE|FALSE|TRUE
FALSE|TRUE|TRUE
FALSE|FALSE|FALSE


## 整数型と実数型、論理型

* Rには整数と実数と論理型があります
* 論理型を数値として評価するとTRUE → 1, FALSE → 0になります
* Rでは事前に`T`, `F`という変数が定義されていてそれぞれTRUE, FALSEの値を持ちます
    * 短くて使いやすいですが、代入可能なので別の値を入れることが可能なのでバグのもとになる可能性があります
* 型の情報みるには`typeof`を使います

### 練習問題

* `1`の型は何でしょうか
* `2L`の型はなんでしょうか
* ベクトル`c(1, TRUE, 1L)`の型はなんでしょうか

## 変数

* 値に名前をつけて参照できるようにしたものを変数と言います
* 変数名に使用できるのは文字と数字、`.`と`_`です
    * 一文字目に数字と`_`を使うことはできません
    * `.`で始まる名前は使えますが`ls()`で出てこないなど特殊な扱いをされるので使用はおすすめしません

```r
# 有効な名前
snake_case
CamelCase
val1
t.test

# 無効な名前
3A
_._._

```

## ベクトル

* Rの基本的な演算はベクトル演算で行われます
* ベクトルの長さを調べるには`length`を使います
* ベクトルからのデータ抽出方法は色々あります

### ベクトルの作り方

* `c(1, 3, 5, 7, 9)`
* `1:10`
* 他にも

```r
# 2と4を3回繰り返す
> rep(c(2,4), 3)
[1] 2 4 2 4 2 4

# 1から10まで4ずつ増加する数列
> seq(1, 10, 4)
[1] 1 5 9

# 0を5個並べた数列
> numeric(5)
[1] 0 0 0 0 0
```

#### 練習問題

* 1から100まで数列が100回繰り返す数列を作ってください
* 0から500まで25ずつ増加する数列を作ってください
* その数列の長さはなんでしょうか

### ベクトルの書き換え方

前回やっていませんが、ついでに。

代入演算子をつかってベクトルの要素を書き換えることができます。

```r
> a <- 1:10
> a[5] <- 0
> a
[1]  1  2  3  4  0  6  7  8  9 10
```

#### 練習問題

* ベクトル`1:100`の要素が偶数の箇所を、すべてその要素+1の値で置き換えてみてください

### ヘルプの見方

Rのヘルプはちょっと読みづらいので、`seq`を例にとって説明します。

```r
> ?seq
```

### ここまで前回の復習と補足

他に前回の内容でもう一度聞きたいことはありますか

# 文字列型とファクター

## 文字列型(character)

* 文字列とは0文字以上の文字が並んだもののことです
* 一般的なプログラミング言語では文字のことをcharacter、文字列のことをstringと呼ぶことが多いです
* 文字列はシングルクオートかダブルクオートで囲んで表現します

```r
> "これは文字列です"
[1] "これは文字列です"

> 'これも文字列です'
[1] "これも文字列です"

# 長さ0の文字列も文字列です。空文字列と呼びます
> ""
[1] ""

> "ダブルクオートの中には'を入れられます"
[1] "ダブルクオートの中には'を入れられます"

> "ダブルクオートの中にはダブルクオートを入れたいときは\"と書きます"
[1] "ダブルクオートの中にはダブルクオートを入れたいときは\"と書きます"

> '同じくシングルクオートの中に"はそのまま、シングルクオートは\'と書きます'
[1] "同じくシングルクオートの中に\"はそのまま、シングルクオートは'と書きます"

> "もしバックスラッシュを書きたいときは\\と2個書きます"
[1] "もしバックスラッシュを書きたいときは\\と2個書きます"
```

この`\`(日本語の環境では￥にみえることがあります)と、それに続く文字をエスケープシーケンスといい、直接書くことができない文字を表現する手法です。

ほかにも`\n` (改行コード)、`\t` (タブ文字)などのエスケープシーケンスはよく使います。

Rのコンソールではエスケープシーケンスが入ったままの文字が表示されます。
`cat`を使うとエスケープシーケンスを評価した値を表示できます。

```r
> "foo\n\tbar\tbaz"
[1] "foo\n\tbar\tbaz"

> cat("foo\n\tbar\tbaz")
foo
	bar	baz
```

文字列の長さを調べるにはncharを使います

```r
> nchar("hoge")
[1] 4
```

文字列もベクトルの要素として使えます

```r
> c("foo", "bar", "buz")
[1] "foo" "bar" "buz"

> typeof(c("foo", "bar", "buz"))
[1] "character"
```

## ファクター(factor)

ファクター(因子)はベクトルの一種で、カテゴリカルデータを表現するために使います。

ファクターは、主にサンプルのcase/control情報や男女の情報などを扱うときに、水準を文字で表現します。
そのため各水準に`1,2`など数値を割り当てるよりも読みやすくなります。

```r
# 文字列のベクトルからファクターを作る
> x <- factor(c("male", "female", "female", "male"))
> x
[1] male   female female male  
Levels: female male
```

`male`, `female`の2水準からなる長さ4のファクターを作りました。
Rはfactor`に与えられたベクトルの中身を調べ、自動的に水準を作ってくれます。

上記で見たように、見た目は文字列とよく似ていますが、実態はかなり異なっています。

```r
# xの型は整数
> typeof(x)
[1] "integer"

# 含まれる水準を取得する
> levels(x)
[1] "female" "male"

# 数値として見ることもできる
> as.numeric(x)
[1] 2 1 1 2
```

これはファクターの実態が、カテゴリ名と、そのカテゴに自動的に割り振った数値のベクトルで構成されるためです
保持しているカテゴリ名は`levels`で見ることができます。

![factor](https://raw.githubusercontent.com/holrock/rstudy/master/images/2-1-factor.png)

### 落とし穴

levelsに含まれていないカテゴリを使うことはできません

```r
> x <- factor(c("male", "female", "female", "male"))
> x
[1] male   female female male  
Levels: female male

# femaleは含まれてるので使えます
> x[1] <- "female"
> x
[1] female female female male  
Levels: female male

# notknownは使えません
> x[1] <- "notknown"
 警告メッセージ: 
 `[<-.factor`(`*tmp*`, 1, value = "notknown") で: 
  invalid factor level, NA generated

> x
[1] <NA>   female female male  
Levels: female male
```

事前にわかっているときは、生成時に明示的に指定します

```r
> x <- factor(c("male", "female", "female", "male"), levels=c("male", "female", "notknown"))
> x
[1] male   female female male  
Levels: male female notknown
> x[1] <- "notknown"
> x
[1] notknown female   female   male    
Levels: male female notknown
```

## 順序付きファクター

通常は`levels`の順序には意味がありません。
デフォルトだと辞書順で順序付けられます。
順序を制御したいときは`factor`を作るときに`levels`と`order=TRUE`を指定します。

```r
> factor(c("notknown", "male", "female"), levels=c("female", "male", "notknown"), ordered=TRUE)
[1] notknown male     female  
Levels: female < male < notknown
```

あとから並べ替えたいときは`reorder`が使えます。

### 落とし穴

#### 文字列とファクター

* Rのデータ読み込み機能(`read.table`など)でデータをファイルから読み込んだときに、自動的に文字列からファクターに変換します。
    * そのため扱っているデータが文字列かと思ったら実際はファクターだったりすることが多いです。
    * 文字列で読み込みたいなら`read.table`するときに`stringsAsFactors=FALSE`を指定します
* またテキストファイルによっては、`NA`の代わりに`-`などが使われているケースがありますが、これを読み込むと`-`を含む列全体がファクターだと解釈されてしまいます。
    * 数値として読めないものが混じってる→文字列で読もう→文字列ならファクターに変換だ　という動きになります
    * この場合は`read.table`に`na.strings="-"`を指定して回避します
    * 欠損値以外の文字が混じっているものは、読み込んだあとファクターから文字列に変換して、さらに数値に変換することになります
* データフレームという機能を使うときに影響を受けることが多いです
    * データフレームは次の回で説明する予定です

```r
# こういう内容のテキストファイルがあったと仮定して
> s <- "value\n12\n1\n-\n9"
> cat(s)
value
12
1
-
9

# それを読み込んでいます
> z <- read.table(text = s, header=TRUE, sep=",")

# zはデータフレームです
> z
  value
1    12
2     1
3     -
4     9

# 数値がほしいところがファクターになってしまいました
> z$value
[1] 12 1  -  9 
Levels: - 1 12 9

# 今度はna.stringsを明示します
> w <- read.table(text = s, header=TRUE, sep=",", na.strings="-")

> w
  value
1    12
2     1
3    NA
4     9

# NAを含むベクトルになっています
> w$value
[1] 12  1 NA  9
```

###  練習問題

* 月曜から日曜までの曜日でファクターを作ってみてください
    * 英語が楽です
* 日曜日は2回以上、月曜日は0回出現するファクターを作ってみてください
    * ただし月曜日がlevelsからなくならないようにしてください
* 日曜が1、月曜が7になるようにファクターを作ってみてください
* つくったファクターに対して`table`を使ってみてください。どういう動作でしょうか
* ファクターに`nchar`を使用するとどうなるでしょうか

## 補足

データ型には他にも日付型(POSIXct)などがありますが、とりあえず扱いません。

# マトリックス(matrix)

Rにおけるマトリックスはベクトルに次元情報をつけたものとして表現されます。

Rで統計処理するときには、`fisher.test`のインプットがマトリックスなので使います。

## マトリックスの作り方

マトリックスを作るには`matrix`を使います

```r
# 1:6のベクトルから3列2行のマトリックスを作る
> matrix(1:6, ncol=3, nrow=2)
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

# 行数と列数はどちらかだけでもOK
> matrix(1:6, ncol=3)
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

# ベクトルを行方向に配置するときはbyrow=TRUEを指定します
# 行優先と言います
> matrix(1:6, ncol=3, byrow=TRUE)
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6
```

![rowcol](https://raw.githubusercontent.com/holrock/rstudy/master/images/2-2-rowcol.png)

上にありますが、ベクトルに次元情報をつければマトリックスになります

```r
> v <- 1:6
> dim(v) <- c(2,3)
> v
     [,1] [,2] [,3]
[1,]    1    3    5
[2,]    2    4    6

# 次元情報の取得
> dim(v)
[1] 2 3
> nrow(v)
[1] 2
> ncol(v)
[1] 3
```

## 演算

ベクトルと同じようにマトリックスの演算も簡潔に書けるようになっています

```r
> A <- matrix(c(5, -7, 6, 8), ncol=2)
> A
     [,1] [,2]
[1,]    5    6
[2,]   -7    8
> B <- matrix(c(2, -3, 4, -5), ncol=2)
> A + B
     [,1] [,2]
[1,]    7   10
[2,]  -10    3
> A - B
     [,1] [,2]
[1,]    3    2
[2,]   -4   13

# スカラー倍
> A * 5
     [,1] [,2]
[1,]   25   30
[2,]  -35   40

# 注意！ 要素ごとの積です
> A * B
     [,1] [,2]
[1,]   10   24
[2,]   21  -40

# 行列積はこっち
> A %*% B
     [,1] [,2]
[1,]   -8  -10
[2,]  -38  -68

# 要素ごとの比較
> A == B
      [,1]  [,2]
[1,] FALSE FALSE
[2,] FALSE FALSE
```

## 要素の抽出

マトリックス要素を参照するには行と列を指定してアクセスします。
複数の要素も取得できます。

```r
> A <- matrix(1:6, ncol=3, byrow=TRUE)

> A
     [,1] [,2] [,3]
[1,]    1    2    3
[2,]    4    5    6

> A[1, 1]
[1] 1

> A[2, 2]
[1] 5

# 1行目すべて
> A[1,]
[1] 1 2 3

# 2列目すべて
> A[,2]
[1] 2 5
```

マトリックスの実態はベクトルなので、ベクトルのように要素番号でのアクセスもできます。
列優先(Column Major)なので注意してください。

```r
# 列優先なので4番目には5が入っています
> A[4]
[1] 5

# 論理値もつかえます
> A[A %% 2 == 0]
[1] 4 2 6

# 書き換えもベクトルと同じです
> A[2, 3] <- 99

> A
     [,1] [,2] [,3]
[1,]    1    2    3
```

## 落とし穴

* マトリックスは実態はベクトルなので、ベクトルと同じく、同じデータ型しか表現できません
* 複数の型を持つベクトルを作ろうとすると同じ型に自動的に変換されます
* データフレームからマトリックスに変換しようとすると想定外の動作をすることがあるので気をつけてください

```r
> x <- data.frame(a=1:3, b=c("A","B","C"))
> x
  a b
1 1 A
2 2 B
3 3 C

# 全部文字列型になっています
> as.matrix(x)
     a   b  
[1,] "1" "A"
[2,] "2" "B"
[3,] "3" "C"
```


## array

Rでは3次元以上のデータ構造をarrayと呼びます。あまり使うことは無いと思うので説明は省きます。

## 練習問題

* `A <- matrix(1:6, ncol=3)`のとき
* `A %*% t(A)`は何をする操作でしょうか
* `A * t(A)`がエラーになる理由はなんでしょうか
* 行ごとの算術平均を計算してみましょう
    * `mean`
* 列ごとの総和を計算してみましょう
    * `sum`

# 欠損値、非数値

## NA

Rにおける欠損値は`NA`で表します。

```r
# NAを含むベクトルを作成
> c(1, NA, 3)
[1]  1 NA  3
```

`NA`は演算することができません。

```r
> 1 + NA
[1] NA

# 比較もできません
> NA == 1
[1] NA

> NA == NA
[1] NA

# NAかどうか判定するにはis.naを使います
> is.na(NA)
[1] TRUE
```

## NULL

`NA`に似たものとして`NULL`があります

`NULL`は何もないということを表現する他の値で、`NA`とは異なります。

プログラマーはヌルと読むことが多いです。

```r
# NULLを含むベクトルを作成できない
  c(1, NULL, 3)
[1] 1 3

# NULLかどうか判定するにはis.nullを使います
> is.null(NULL)
[1] TRUE
```

## NaN

`NaN`はNot a Numberの略で非数を意味する値です。
`NA`は主にデータの読み込みなどで抜けている値を表現しますが、`NaN`は演算中に数値にならないものが出てきてしまったときに使われます

```r
> 0 / 0
[1] NaN

> is.nan(NaN)
[1] TRUE

# NaNはNAとしても判定されます
> is.na(NaN)
[1] TRUE

# NAはNaNではありません
> is.nan(NA)
[1] FALSE
```

## Inf

`Inf`は無限を意味する値です。これも演算中に出てきたり、無効な値の初期値として使うことがあります。

```r
> 1 / 0
[1] Inf

# is.infじゃない
> is.infinite(Inf)
[1] TRUE

# マイナス無限大も作れます
> -Inf
[1] -Inf

# Infは数値扱いとして比較できます
> Inf == Inf
[1] TRUE

# +Infは常に他の値より大きくなります
> Inf > 999999999999999
[1] TRUE
```

## 練習問題

* `dim(1)`が`NULL`になるのはなぜでしょうか
* `is.infinite(NA)`の結果はどうなるでしょうか
* `c(1, NA, NaN)`の`NA`と`NaN`を1に書き換えてみてください
* `c(1, NA, NaN)`の`NA`だけを2に書き換えてみてください
