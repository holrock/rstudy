# 今回の内容

* 前回の続き(欠損値、非数値から)

# データフレーム

データフレームはRで一番使われるデータ構造です。

データフレームは同じ長さのベクトルのリストで表現されます。
リストなので、マトリックスと違い、別の型を保持できます。

サンプルデータセットのirisを例に見てみます。

```r
> head(iris)
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa
4          4.6         3.1          1.5         0.2  setosa
5          5.0         3.6          1.4         0.2  setosa
6          5.4         3.9          1.7         0.4  setosa

> str(iris)
'data.frame':	150 obs. of  5 variables:
 $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
 $ Sepal.Width : num  3.5 3 3.2 3.1 3.6 3.9 3.4 3.4 2.9 3.1 ...
 $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...
 $ Petal.Width : num  0.2 0.2 0.2 0.2 0.2 0.4 0.3 0.2 0.2 0.1 ...
 $ Species     : Factor w/ 3 levels "setosa","versicolor",..: 1 1 1 1 1 1 1 1 1 1 ...

# 型はリストです
> typeof(iris)
[1] "list"

# データフレームとして特性はクラスという機能で実現しています
> class(iris)
[1] "data.frame"
```

![dataframe](https://raw.githubusercontent.com/holrock/rstudy/master/images/4-1.png)

データフレームはリストであるというのは重要なので覚えておいてください。

## データフレームの生成

* `read.table`で読み込んだデータはデータフレームになります。
* 手動で作るときは`data.frame`を使います
* 他の型から変換するときは`as.data.frame`を使います

ファクターのときにも言及しましたが、`data.frame`などは文字列をファクターに自動変換します。
思いがけないエラーの原因になるので気をつけてください。
変換をやめたいときは`stringsAsFactors=FALSE`を指定してください。

```r
# x, yという列を持つデータフレームを作ります
> df <- data.frame(x=1:3, y=c("a", "b", "c"))
> 
> df
  x y
1 1 a
2 2 b
3 3 c

> str(df)
'data.frame':	3 obs. of  2 variables:
 $ x: int  1 2 3
 $ y: Factor w/ 3 levels "a","b","c": 1 2 3

> df <- data.frame(x=1:3, y=c("a", "b", "c"), stringsAsFactors=FALSE)
> str(df)
'data.frame':	3 obs. of  2 variables:
 $ x: int  1 2 3
 $ y: chr  "a" "b" "c"

> as.data.frame(matrix(1:9,nrow=3))
  V1 V2 V3
1  1  4  7
2  2  5  8
3  3  6  9

# サイズはncol, nrow, dimで取得できます
> ncol(df)
[1] 2
> nrow(df)
[1] 3
> dim(df)
[1] 3 2

# 行や列についた名前も取得できます
> names(df)
[1] "x" "y"
> rownames(df)
[1] "1" "2" "3"
> colnames(df)
[1] "x" "y"

# 変更もできます
> colnames(df) <- c("new_x", "new_y")
> df
  new_x new_y
1     1     a
2     2     b
3     3     c
```

## データフレームへのアクセス

データフレームの要素へは、リストと同じ方法、またはマトリックスと同じ方法でアクセスできます。
混乱しやすいので、扱っているデータが単なるリストかデータフレームなのかはしっかり把握する必要があります。


### リスト方式

```r
# 1列目
> iris[[1]]
  [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5
...

# 名前で列を指定
> iris[["Sepal.Length"]]
  [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5
...

# リストと同じくiris[["Sepal.Length"]]と同義
> iris$Sepal.Length
  [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5
...
```

上記のアクセス方法では対象の**1列だけ**が**ベクトル**として取り出されます。

複数の列を取り出すときは次のようにアクセスします。
戻ってくるのは**データフレーム**です。

```r
# 1,2,3列目をデータフレームとしてアクセス
> x <- iris[c(1,3)]
> head(x)
  Sepal.Length Petal.Length
1          5.1          1.4
2          4.9          1.4
3          4.7          1.3
4          4.6          1.5
5          5.0          1.4
6          5.4          1.7

> str(x)
'data.frame':	150 obs. of  2 variables:
 $ Sepal.Length: num  5.1 4.9 4.7 4.6 5 5.4 4.6 5 4.4 4.9 ...
 $ Petal.Length: num  1.4 1.4 1.3 1.5 1.4 1.7 1.4 1.5 1.4 1.5 ...

> is.data.frame(x)
[1] TRUE

# 名前で複数アクセス
> x <- iris[c("Sepal.Length", "Petal.Length")]
> head(x)
  Sepal.Length Petal.Length
1          5.1          1.4
2          4.9          1.4
3          4.7          1.3
4          4.6          1.5
5          5.0          1.4
6          5.4          1.7

# このときは1列でもデータフレーム
> x <- iris[1]
> head(x)
  Sepal.Length
1          5.1
2          4.9
3          4.7
4          4.6
5          5.0
6          5.4
```

`[`と`[[`の違いには気をつけてください。

### マトリックス方式

```r
# 一列目を全て
> iris[, 1]
  [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5
...

# 名前の列を全て
> iris[, "Sepal.Length"]
  [1] 5.1 4.9 4.7 4.6 5.0 5.4 4.6 5.0 4.4 4.9 5.4 4.8 4.8 4.3 5.8 5.7 5.4 5.1 5.7 5.1 5.4 5.1 4.6 5.1 4.8 5.0 5.0 5.2 5.2 4.7 4.8 5.4 5.2 5.5
...

# 1,2,3行目をすべての列
> iris[1:3, ]
  Sepal.Length Sepal.Width Petal.Length Petal.Width Species
1          5.1         3.5          1.4         0.2  setosa
2          4.9         3.0          1.4         0.2  setosa
3          4.7         3.2          1.3         0.2  setosa

# 1,2,3行、1,2,3列
> iris[1:3, 1:3]
  Sepal.Length Sepal.Width Petal.Length
1          5.1         3.5          1.4
2          4.9         3.0          1.4
3          4.7         3.2          1.3

# 負数のときはそれ以外
> iris[1:3, c(-1, -3)]
  Sepal.Width Petal.Width Species
1         3.5         0.2  setosa
2         3.0         0.2  setosa
3         3.2         0.2  setosa

# Speciesが virginica以外の行
> iris[iris$Species == "virginica",  ]
    Sepal.Length Sepal.Width Petal.Length Petal.Width   Species
101          6.3         3.3          6.0         2.5 virginica
102          5.8         2.7          5.1         1.9 virginica
103          7.1         3.0          5.9         2.1 virginica
104          6.3         2.9          5.6         1.8 virginica
...

# subsetを使うと省略してかけます
> subset(iris, Species == "virginica", select=c(Sepal.Length, Petal.Length))
    Sepal.Length Petal.Length
101          6.3          6.0
102          5.8          5.1
103          7.1          5.9
104          6.3          5.6
105          6.5          5.8
106          7.6          6.6
...

# 無視する名前指定もできます
> subset(iris, select=-Sepal.Length)
  Sepal.Width Petal.Length Petal.Width Species
1         3.5          1.4         0.2  setosa
2         3.0          1.4         0.2  setosa
3         3.2          1.3         0.2  setosa
4         3.1          1.5         0.2  setosa
5         3.6          1.4         0.2  setosa
6         3.9          1.7         0.4  setosa
...
```

`subset`は便利ですが、`()`の中の扱いが通常と異なるので混乱しやすいです。
わからなくなったら通常の方法で試してみるのをおすすめします。

#### 落とし穴

上の例では、取得できた型にベクトルとデータフレームが混在しています。
Rはデータフレームへアクセスするとき、結果に複数の列が含まれるときはデータフレーム、1列しか含まれないときはベクトルに変換を行います。

```r
# ベクトルです
> iris[1, 1]
[1] 5.1

# データフレームです
> iris[1, 1:2]
  Sepal.Length Sepal.Width
1          5.1         3.5
```

データフレームが戻ってくると期待して書かれていたプログラムが、アクセスする列が減っただけで動かなくなるので注意が必要です。逆のケースもあります。
(同じ問題はマトリックスでも起こります)

常にデータフレームにしたいときは`drop=FALSE`を指定することで強制できます。

```r
> iris[1, 1, drop=FALSE]
  Sepal.Length
1          5.1
```

アクセスの方法でエラーになったりならなかったりすると、慣れてないうちは混乱してしまします。
そういうときはゆっくり`str`などで型を確認したり、アクセスの方法を見直してみましょう。

### 練習問題

`mtcars`というデータセットに対して

* オートマチックの車だけ取り出してみてください
    * `?mtcars`で説明が出ます
* 燃費の悪い順にデータフレームを並べ替えてみてください
    * `order(mtcars$mpg)`が燃費悪い順の行インデックスです
* 燃費の悪い順に並べた車名を取得してみてください
    * 車名は行名になっているので`rownames`で取得できます

## 結合

データフレームに新たな列や行を付け加えるには`cbind`, `rbind`を使います。

```r
> df <- data.frame(x=1:3, y=c("a", "b", "c"))

# 列を追加
> cbind(df, z=4:6)
  x y z
1 1 a 4
2 2 b 5
3 3 c 6

# 行を追加
> rbind(df, list(1, "a"))
  x y
1 1 a
2 2 b
3 3 c
4 1 a

# ファクターにない水準を入れようとすると警告が出ます
> rbind(df, list(1, "d"))
  x    y
1 1    a
2 2    b
3 3    c
4 1 <NA>
 警告メッセージ: 
 `[<-.factor`(`*tmp*`, ri, value = "d") で: 
   不正な因子水準です。NA が発生しました

# 行の数が違うときはエラーになりますが
> cbind(df, z=4:7)
 data.frame(..., check.names = FALSE) でエラー: 
   引数に異なる列数のデータフレームが含まれています: 3, 4


# エラーにならないこともあります
> cbind(df, z=4)
  x y z
1 1 a 4
2 2 b 4
3 3 c 4

 > cbind(df, z=4:9)
  x y z
1 1 a 4
2 2 b 5
3 3 c 6
4 1 a 7
5 2 b 8
6 3 c 9

# 行が足りないときや多すぎるときは、注意してください

# 直接列を追加することもできます
> df$z <- 4:6
> df
  x y z
1 1 a 4
2 2 b 5
3 3 c 6

# NULLを入れると列が消えます
> df$z <- NULL
> df
  x y
1 1 a
2 2 b
3 3 c

# mergeもできます
> df2 <- data.frame(y=1:3, z=c(0.1, 0.2, 0.3))
> merge(x=df, y=df2, by.x="x", by.y="y")
  x y   z
1 1 a 0.1
2 2 b 0.2
3 3 c 0.3
```

### 落とし穴

`rbind`や`cbind`を多用すると計算時間や使用するメモリーが増えることがあります。

## データの読み書き

データフレームをファイルに保存したり、読み込むことも可能です。

```r
# 書き込み
# カンマ区切りで行名を省いたファイルを出力する
write.table(df, file="dataframe.txt", quote=FALSE, sep=",", row.names=FALSE)
# 列名があるカンマ区切りファイルを読み込む
new_df <- read.table(file="dataframe.txt", sep=",", heade=TRUE)
```

いろいろなオプションがありますが、`quote`, `sep`, `header`はできるだけ指定したほうが間違えづらいです。
また、Excel(`readxl`パッケージ)やSPSS(`read.spss`)などのファイルも読むことができます。
ただ、各ソフトからCSVファイルなどの形式で出力したものを読むほうが汎用性が高くなります。

## データ設計

Rを使う上でデータフレームは避けて通れません。
その中でも使いやすいデータフレームと使いにくいデータフレームがあります。

使いづらいデータフレームは次のようなものです

* 列が独立した意味を持っていない
    * 同じ列に意味の異なるデータが入ってはいけません
    * 単位が違うものなど
* 列名、行名が隠れた値になっている
    * たとえば日付が列名になっているとき、それも値として扱いたいいのであれば列名ではなく別の列として持つべきかどうかを考える必要があります
    * `mtcars`の行名が車の名前なのはだめな例です
* 横長なデータ
    * 特に新たなデータが増えるたびに横にも増えていくデータは大抵の場合、プログラム上では使いづらくなります
    * 横に増えていということは、列名に値が入っていることになります
    * また行ごとに列数が異なってしまいやすく、そうなるとデータとして一段と難しくなります
    * 横長データは縦長にすると使いやすくなる事が多いです

### 横長で、列が独立してなくて、列名に値が隠れているデータ
 
SAMPLE|5/1-1|5/1-2|5/10-1|5/10-2|5/20-1|5/20-2|...
----------|------|------|-------|--------|--------|-------|---
sample1|1       |2      |3        |4         |5         |6        |...
sample2|1       |2      |3        |4         |5         |6        |...
sample3|1       |2      |3        |4         |5         |6        |...
合計       |3       |6      |9        |12       |15       |18      |...

### 縦長データ

SAMPLE|date|1|2
----------|-----|-|-
sample1|5/1|1|2
sample1|5/10|3|4
sample1|5/20|5|6
sample2|5/1|1|2
sample2|5/10|3|4
sample2|5/20|5|6
sample3|5/1|1|2
sample3|5/10|3|4
sample3|5/20|5|6

エクセル上で人力でデータを作っていると、機械可読性の低いデータになりがちです。

使いやすいデータ設計の情報として、[整然データとは何か](http://id.fnshr.info/2017/01/09/tidy-data-intro/) がわかりやすいのでぜひ読んでください。

## 発展的な話題

* 上記の整然データでも触れられていますが`tidyverse`というライブラリ群があります。
* [RユーザのためのRStudio[実践]入門−tidyverseによるモダンな分析フローの世界−](https://www.amazon.co.jp/dp/4774198536) という本も出るようです
    * 中身は読んでないのでわかりません
